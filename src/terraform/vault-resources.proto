syntax = "proto3";

package terraform.vault.resources;

import "terraform/meta.proto";

//VaultAlicloudAuthBackendRole version is 0
message VaultAlicloudAuthBackendRole {
  //The role's arn.
  string arn = 1;

  //Auth backend.
  string backend = 2;

  string id = 3;

  //Name of the role. Must correspond with the name of the role reflected in the arn.
  string role = 4;

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 5 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 6 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 7 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 8 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 9 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 10 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 11 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 12 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 13 [json_name = "token_type"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 14;

  int32 count = 15;

  terraform.meta.MetaFields.ForEachEntry for_each = 16;

  string provider = 17;

  terraform.meta.Lifecycle lifecycle = 18;
}

//VaultApproleAuthBackendLogin version is 0
message VaultApproleAuthBackendLogin {
  //The accessor for the token.
  string accessor = 1;

  //Unique name of the auth backend to configure.
  string backend = 2;

  //The token.
  string client_token = 3 [json_name = "client_token"];

  string id = 4;

  //How long the token is valid for.
  int64 lease_duration = 5 [json_name = "lease_duration"];

  //The timestamp the lease started on, as determined by the machine running Terraform.
  string lease_started = 6 [json_name = "lease_started"];

  //Metadata associated with the token.
  map<string, string> metadata = 7;

  //Policies set on the token.
  repeated string policies = 8;

  //Whether the token is renewable or not.
  bool renewable = 9;

  //The RoleID to log in with.
  string role_id = 10 [json_name = "role_id"];

  //The SecretID to log in with.
  string secret_id = 11 [json_name = "secret_id"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 12;

  int32 count = 13;

  terraform.meta.MetaFields.ForEachEntry for_each = 14;

  string provider = 15;

  terraform.meta.Lifecycle lifecycle = 16;
}

//VaultApproleAuthBackendRole version is 0
message VaultApproleAuthBackendRole {
  //Unique name of the auth backend to configure.
  string backend = 1;

  //Whether or not to require secret_id to be present when logging in using this AppRole.
  bool bind_secret_id = 2 [json_name = "bind_secret_id"];

  //List of CIDR blocks that can log in using the AppRole.
  repeated string bound_cidr_list = 3 [json_name = "bound_cidr_list"];

  string id = 4;

  //Number of seconds to set the TTL to for issued tokens upon renewal. Makes the token a periodic token, which will never expire as long as it is renewed before the TTL each period.
  int64 period = 5;

  //Policies to be set on tokens issued using this AppRole.
  repeated string policies = 6;

  //The RoleID of the role. Autogenerated if not set.
  string role_id = 7 [json_name = "role_id"];

  //Name of the role.
  string role_name = 8 [json_name = "role_name"];

  //List of CIDR blocks that can log in using the AppRole.
  repeated string secret_id_bound_cidrs = 9 [json_name = "secret_id_bound_cidrs"];

  //Number of times which a particular SecretID can be used to fetch a token from this AppRole, after which the SecretID will expire. Leaving this unset or setting it to 0 will allow unlimited uses.
  int64 secret_id_num_uses = 10 [json_name = "secret_id_num_uses"];

  //Number of seconds a SecretID remains valid for.
  int64 secret_id_ttl = 11 [json_name = "secret_id_ttl"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 12 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 13 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 14 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 15 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 16 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 17 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 18 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 19 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 20 [json_name = "token_type"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 21;

  int32 count = 22;

  terraform.meta.MetaFields.ForEachEntry for_each = 23;

  string provider = 24;

  terraform.meta.Lifecycle lifecycle = 25;
}

//VaultApproleAuthBackendRoleSecretId version is 0
message VaultApproleAuthBackendRoleSecretId {
  //The unique ID used to access this SecretID.
  string accessor = 1;

  //Unique name of the auth backend to configure.
  string backend = 2;

  //List of CIDR blocks that can log in using the SecretID.
  repeated string cidr_list = 3 [json_name = "cidr_list"];

  string id = 4;

  //JSON-encoded secret data to write.
  string metadata = 5;

  //Name of the role.
  string role_name = 6 [json_name = "role_name"];

  //The SecretID to be managed. If not specified, Vault auto-generates one.
  string secret_id = 7 [json_name = "secret_id"];

  //The wrapped SecretID accessor.
  string wrapping_accessor = 8 [json_name = "wrapping_accessor"];

  //The wrapped SecretID token.
  string wrapping_token = 9 [json_name = "wrapping_token"];

  //The TTL duration of the wrapped SecretID.
  string wrapping_ttl = 10 [json_name = "wrapping_ttl"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 11;

  int32 count = 12;

  terraform.meta.MetaFields.ForEachEntry for_each = 13;

  string provider = 14;

  terraform.meta.Lifecycle lifecycle = 15;
}

//VaultAudit version is 0
message VaultAudit {
  //Human-friendly description of the audit device
  string description = 1;

  string id = 2;

  //Configuration options to pass to the audit device itself
  map<string, string> options = 3;

  //Path in which to enable the audit device
  string path = 4;

  //Type of the audit device, such as 'file'
  string type = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultAuthBackend version is 1
message VaultAuthBackend {
  //The accessor of the auth backend
  string accessor = 1;

  //Default lease duration in seconds
  int64 default_lease_ttl_seconds = 2 [json_name = "default_lease_ttl_seconds"];

  //The description of the auth backend
  string description = 3;

  string id = 4;

  //Specifies whether to show this mount in the UI-specific listing endpoint
  string listing_visibility = 5 [json_name = "listing_visibility"];

  //Specifies if the auth method is local only
  bool local = 6;

  //Maximum possible lease duration in seconds
  int64 max_lease_ttl_seconds = 7 [json_name = "max_lease_ttl_seconds"];

  //path to mount the backend. This defaults to the type.
  string path = 8;

  repeated Tune tune = 9;

  //Name of the auth backend
  string type = 10;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 11;

  int32 count = 12;

  terraform.meta.MetaFields.ForEachEntry for_each = 13;

  string provider = 14;

  terraform.meta.Lifecycle lifecycle = 15;

  message Tune {
    //allowed_response_headers: list of string
    repeated string allowed_response_headers = 1 [json_name = "allowed_response_headers"];

    //audit_non_hmac_request_keys: list of string
    repeated string audit_non_hmac_request_keys = 2 [json_name = "audit_non_hmac_request_keys"];

    //audit_non_hmac_response_keys: list of string
    repeated string audit_non_hmac_response_keys = 3 [json_name = "audit_non_hmac_response_keys"];

    //default_lease_ttl: string
    string default_lease_ttl = 4 [json_name = "default_lease_ttl"];

    //listing_visibility: string
    string listing_visibility = 5 [json_name = "listing_visibility"];

    //max_lease_ttl: string
    string max_lease_ttl = 6 [json_name = "max_lease_ttl"];

    //passthrough_request_headers: list of string
    repeated string passthrough_request_headers = 7 [json_name = "passthrough_request_headers"];

    //token_type: string
    string token_type = 8 [json_name = "token_type"];
  }
}

//VaultAwsAuthBackendCert version is 0
message VaultAwsAuthBackendCert {
  //Base64 encoded AWS Public key required to verify PKCS7 signature of the EC2 instance metadata.
  string aws_public_cert = 1 [json_name = "aws_public_cert"];

  //Unique name of the auth backend to configure.
  string backend = 2;

  //Name of the certificate to configure.
  string cert_name = 3 [json_name = "cert_name"];

  string id = 4;

  //The type of document that can be verified using the certificate. Must be either "pkcs7" or "identity".
  string type = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultAwsAuthBackendClient version is 0
message VaultAwsAuthBackendClient {
  //AWS Access key with permissions to query AWS APIs.
  string access_key = 1 [json_name = "access_key"];

  //Unique name of the auth backend to configure.
  string backend = 2;

  //URL to override the default generated endpoint for making AWS EC2 API calls.
  string ec2_endpoint = 3 [json_name = "ec2_endpoint"];

  //URL to override the default generated endpoint for making AWS IAM API calls.
  string iam_endpoint = 4 [json_name = "iam_endpoint"];

  //The value to require in the X-Vault-AWS-IAM-Server-ID header as part of GetCallerIdentity requests that are used in the iam auth method.
  string iam_server_id_header_value = 5 [json_name = "iam_server_id_header_value"];

  string id = 6;

  //AWS Secret key with permissions to query AWS APIs.
  string secret_key = 7 [json_name = "secret_key"];

  //URL to override the default generated endpoint for making AWS STS API calls.
  string sts_endpoint = 8 [json_name = "sts_endpoint"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;
}

//VaultAwsAuthBackendIdentityWhitelist version is 0
message VaultAwsAuthBackendIdentityWhitelist {
  //Unique name of the auth backend to configure.
  string backend = 1;

  //If true, disables the periodic tidying of the identiy whitelist entries.
  bool disable_periodic_tidy = 2 [json_name = "disable_periodic_tidy"];

  string id = 3;

  //The amount of extra time that must have passed beyond the roletag expiration, before it's removed from backend storage.
  int64 safety_buffer = 4 [json_name = "safety_buffer"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultAwsAuthBackendLogin version is 0
message VaultAwsAuthBackendLogin {
  //The accessor returned from Vault for this token.
  string accessor = 1;

  //The auth method used to generate this token.
  string auth_type = 2 [json_name = "auth_type"];

  //AWS Auth Backend to read the token from.
  string backend = 3;

  //The token returned by Vault.
  string client_token = 4 [json_name = "client_token"];

  //The HTTP method used in the signed request.
  string iam_http_request_method = 5 [json_name = "iam_http_request_method"];

  //The Base64-encoded body of the signed request.
  string iam_request_body = 6 [json_name = "iam_request_body"];

  //The Base64-encoded, JSON serialized representation of the sts:GetCallerIdentity HTTP request headers.
  string iam_request_headers = 7 [json_name = "iam_request_headers"];

  //The Base64-encoded HTTP URL used in the signed request.
  string iam_request_url = 8 [json_name = "iam_request_url"];

  string id = 9;

  //Base64-encoded EC2 instance identity document to authenticate with.
  string identity = 10;

  //Lease duration in seconds relative to the time in lease_start_time.
  int64 lease_duration = 11 [json_name = "lease_duration"];

  //Time at which the lease was read, using the clock of the system where Terraform was running
  string lease_start_time = 12 [json_name = "lease_start_time"];

  //The metadata reported by the Vault server.
  map<string, string> metadata = 13;

  //The nonce to be used for subsequent login requests.
  string nonce = 14;

  //PKCS7 signature of the identity document to authenticate with, with all newline characters removed.
  string pkcs7 = 15;

  //The policies assigned to this token.
  repeated string policies = 16;

  //True if the duration of this lease can be extended through renewal.
  bool renewable = 17;

  //AWS Auth Role to read the token from.
  string role = 18;

  //Base64-encoded SHA256 RSA signature of the instance identtiy document to authenticate with.
  string signature = 19;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 20;

  int32 count = 21;

  terraform.meta.MetaFields.ForEachEntry for_each = 22;

  string provider = 23;

  terraform.meta.Lifecycle lifecycle = 24;
}

//VaultAwsAuthBackendRole version is 0
message VaultAwsAuthBackendRole {
  //When true, allows migration of the underlying instance where the client resides. Use with caution.
  bool allow_instance_migration = 1 [json_name = "allow_instance_migration"];

  //The auth type permitted for this role.
  string auth_type = 2 [json_name = "auth_type"];

  //Unique name of the auth backend to configure.
  string backend = 3;

  //Only EC2 instances with this account ID in their identity document will be permitted to log in.
  string bound_account_id = 4 [json_name = "bound_account_id"];

  //Only EC2 instances with this account ID in their identity document will be permitted to log in.
  repeated string bound_account_ids = 5 [json_name = "bound_account_ids"];

  //Only EC2 instances using this AMI ID will be permitted to log in.
  string bound_ami_id = 6 [json_name = "bound_ami_id"];

  //Only EC2 instances using this AMI ID will be permitted to log in.
  repeated string bound_ami_ids = 7 [json_name = "bound_ami_ids"];

  //Only EC2 instances that match this instance ID will be permitted to log in.
  repeated string bound_ec2_instance_id = 8 [json_name = "bound_ec2_instance_id"];

  //Only EC2 instances that match this instance ID will be permitted to log in.
  repeated string bound_ec2_instance_ids = 9 [json_name = "bound_ec2_instance_ids"];

  //Only EC2 instances associated with an IAM instance profile ARN that matches this value will be permitted to log in.
  string bound_iam_instance_profile_arn = 10 [json_name = "bound_iam_instance_profile_arn"];

  //Only EC2 instances associated with an IAM instance profile ARN that matches this value will be permitted to log in.
  repeated string bound_iam_instance_profile_arns = 11 [json_name = "bound_iam_instance_profile_arns"];

  //The IAM principal that must be authenticated using the iam auth method.
  string bound_iam_principal_arn = 12 [json_name = "bound_iam_principal_arn"];

  //The IAM principal that must be authenticated using the iam auth method.
  repeated string bound_iam_principal_arns = 13 [json_name = "bound_iam_principal_arns"];

  //Only EC2 instances that match this IAM role ARN will be permitted to log in.
  string bound_iam_role_arn = 14 [json_name = "bound_iam_role_arn"];

  //Only EC2 instances that match this IAM role ARN will be permitted to log in.
  repeated string bound_iam_role_arns = 15 [json_name = "bound_iam_role_arns"];

  //Only EC2 instances in this region will be permitted to log in.
  string bound_region = 16 [json_name = "bound_region"];

  //Only EC2 instances in this region will be permitted to log in.
  repeated string bound_regions = 17 [json_name = "bound_regions"];

  //Only EC2 instances associated with this subnet ID will be permitted to log in.
  string bound_subnet_id = 18 [json_name = "bound_subnet_id"];

  //Only EC2 instances associated with this subnet ID will be permitted to log in.
  repeated string bound_subnet_ids = 19 [json_name = "bound_subnet_ids"];

  //Only EC2 instances associated with this VPC ID will be permitted to log in.
  string bound_vpc_id = 20 [json_name = "bound_vpc_id"];

  //Only EC2 instances associated with this VPC ID will be permitted to log in.
  repeated string bound_vpc_ids = 21 [json_name = "bound_vpc_ids"];

  //When true, only allows a single token to be granted per instance ID.
  bool disallow_reauthentication = 22 [json_name = "disallow_reauthentication"];

  string id = 23;

  //The region to search for the inferred entities in.
  string inferred_aws_region = 24 [json_name = "inferred_aws_region"];

  //The type of inferencing Vault should do.
  string inferred_entity_type = 25 [json_name = "inferred_entity_type"];

  //The maximum allowed lifetime of tokens issued using this role, provided as the number of seconds.
  int64 max_ttl = 26 [json_name = "max_ttl"];

  //If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this field. The maximum allowed lifetime of token issued using this role. Specified as a number of seconds.
  int64 period = 27;

  //Policies to be set on tokens issued using this role.
  repeated string policies = 28;

  //Whether or not Vault should resolve the bound_iam_principal_arn to an AWS Unique ID. When true, deleting a principal and recreating it with the same name won't automatically grant the new principal the same roles in Vault that the old principal had.
  bool resolve_aws_unique_ids = 29 [json_name = "resolve_aws_unique_ids"];

  //Name of the role.
  string role = 30;

  //The key of the tag on EC2 instance to use for role tags.
  string role_tag = 31 [json_name = "role_tag"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 32 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 33 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 34 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 35 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 36 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 37 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 38 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 39 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 40 [json_name = "token_type"];

  //The TTL period of tokens issued using this role, provided as the number of seconds.
  int64 ttl = 41;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 42;

  int32 count = 43;

  terraform.meta.MetaFields.ForEachEntry for_each = 44;

  string provider = 45;

  terraform.meta.Lifecycle lifecycle = 46;
}

//VaultAwsAuthBackendRoleTag version is 0
message VaultAwsAuthBackendRoleTag {
  //Allows migration of the underlying instance where the client resides.
  bool allow_instance_migration = 1 [json_name = "allow_instance_migration"];

  //AWS auth backend to read tags from.
  string backend = 2;

  //Only allow a single token to be granted per instance ID.
  bool disallow_reauthentication = 3 [json_name = "disallow_reauthentication"];

  string id = 4;

  //Instance ID for which this tag is intended. The created tag can only be used by the instance with the given ID.
  string instance_id = 5 [json_name = "instance_id"];

  //The maximum allowed lifetime of tokens issued using this role.
  string max_ttl = 6 [json_name = "max_ttl"];

  //Policies to be associated with the tag.
  repeated string policies = 7;

  //Name of the role.
  string role = 8;

  string tag_key = 9 [json_name = "tag_key"];

  string tag_value = 10 [json_name = "tag_value"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 11;

  int32 count = 12;

  terraform.meta.MetaFields.ForEachEntry for_each = 13;

  string provider = 14;

  terraform.meta.Lifecycle lifecycle = 15;
}

//VaultAwsAuthBackendRoletagBlacklist version is 0
message VaultAwsAuthBackendRoletagBlacklist {
  //Unique name of the auth backend to configure.
  string backend = 1;

  //If true, disables the periodic tidying of the roletag blacklist entries.
  bool disable_periodic_tidy = 2 [json_name = "disable_periodic_tidy"];

  string id = 3;

  //The amount of extra time that must have passed beyond the roletag expiration, before it's removed from backend storage.
  int64 safety_buffer = 4 [json_name = "safety_buffer"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultAwsAuthBackendStsRole version is 0
message VaultAwsAuthBackendStsRole {
  //AWS account ID to be associated with STS role.
  string account_id = 1 [json_name = "account_id"];

  //Unique name of the auth backend to configure.
  string backend = 2;

  string id = 3;

  //AWS ARN for STS role to be assumed when interacting with the account specified.
  string sts_role = 4 [json_name = "sts_role"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultAwsSecretBackend version is 0
message VaultAwsSecretBackend {
  //The AWS Access Key ID to use when generating new credentials.
  string access_key = 1 [json_name = "access_key"];

  //Default lease duration for secrets in seconds
  int64 default_lease_ttl_seconds = 2 [json_name = "default_lease_ttl_seconds"];

  //Human-friendly description of the mount for the backend.
  string description = 3;

  string id = 4;

  //Maximum possible lease duration for secrets in seconds
  int64 max_lease_ttl_seconds = 5 [json_name = "max_lease_ttl_seconds"];

  //Path to mount the backend at.
  string path = 6;

  //The AWS region to make API calls against. Defaults to us-east-1.
  string region = 7;

  //The AWS Secret Access Key to use when generating new credentials.
  string secret_key = 8 [json_name = "secret_key"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;
}

//VaultAwsSecretBackendRole version is 0
message VaultAwsSecretBackendRole {
  //The path of the AWS Secret Backend the role belongs to.
  string backend = 1;

  //Role credential type.
  string credential_type = 2 [json_name = "credential_type"];

  //The default TTL in seconds for STS credentials. When a TTL is not specified when STS credentials are requested, and a default TTL is specified on the role, then this default TTL will be used. Valid only when credential_type is one of assumed_role or federation_token.
  int64 default_sts_ttl = 3 [json_name = "default_sts_ttl"];

  //A list of IAM group names. IAM users generated against this vault role will be added to these IAM Groups. For a credential type of assumed_role or federation_token, the policies sent to the corresponding AWS call (sts:AssumeRole or sts:GetFederation) will be the policies from each group in iam_groups combined with the policy_document and policy_arns parameters.
  repeated string iam_groups = 4 [json_name = "iam_groups"];

  string id = 5;

  //The max allowed TTL in seconds for STS credentials (credentials TTL are capped to max_sts_ttl). Valid only when credential_type is one of assumed_role or federation_token.
  int64 max_sts_ttl = 6 [json_name = "max_sts_ttl"];

  //Unique name for the role.
  string name = 7;

  //IAM policy the role should use in JSON format.
  string policy = 8;

  //ARN for an existing IAM policy the role should use.
  string policy_arn = 9 [json_name = "policy_arn"];

  //ARN for an existing IAM policy the role should use.
  repeated string policy_arns = 10 [json_name = "policy_arns"];

  //IAM policy the role should use in JSON format.
  string policy_document = 11 [json_name = "policy_document"];

  //ARNs of AWS roles allowed to be assumed. Only valid when credential_type is 'assumed_role'
  repeated string role_arns = 12 [json_name = "role_arns"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 13;

  int32 count = 14;

  terraform.meta.MetaFields.ForEachEntry for_each = 15;

  string provider = 16;

  terraform.meta.Lifecycle lifecycle = 17;
}

//VaultAzureAuthBackendConfig version is 0
message VaultAzureAuthBackendConfig {
  //Unique name of the auth backend to configure.
  string backend = 1;

  //The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are required.
  string client_id = 2 [json_name = "client_id"];

  //The client secret for credentials to query the Azure APIs
  string client_secret = 3 [json_name = "client_secret"];

  //The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.
  string environment = 4;

  string id = 5;

  //The configured URL for the application registered in Azure Active Directory.
  string resource = 6;

  //The tenant id for the Azure Active Directory organization.
  string tenant_id = 7 [json_name = "tenant_id"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 8;

  int32 count = 9;

  terraform.meta.MetaFields.ForEachEntry for_each = 10;

  string provider = 11;

  terraform.meta.Lifecycle lifecycle = 12;
}

//VaultAzureAuthBackendRole version is 0
message VaultAzureAuthBackendRole {
  //Unique name of the auth backend to configure.
  string backend = 1;

  //The list of group ids that login is restricted to.
  repeated string bound_group_ids = 2 [json_name = "bound_group_ids"];

  //The list of locations that login is restricted to.
  repeated string bound_locations = 3 [json_name = "bound_locations"];

  //The list of resource groups that login is restricted to.
  repeated string bound_resource_groups = 4 [json_name = "bound_resource_groups"];

  //The list of scale set names that the login is restricted to.
  repeated string bound_scale_sets = 5 [json_name = "bound_scale_sets"];

  //The list of Service Principal IDs that login is restricted to.
  repeated string bound_service_principal_ids = 6 [json_name = "bound_service_principal_ids"];

  //The list of subscription IDs that login is restricted to.
  repeated string bound_subscription_ids = 7 [json_name = "bound_subscription_ids"];

  string id = 8;

  //The maximum allowed lifetime of tokens issued using this role, provided as the number of seconds.
  int64 max_ttl = 9 [json_name = "max_ttl"];

  //If set, indicates that the token generated using this role should never expire. The token should be renewed within the duration specified by this value. At each renewal, the token's TTL will be set to the value of this field. The maximum allowed lifetime of token issued using this role. Specified as a number of seconds.
  int64 period = 10;

  //Policies to be set on tokens issued using this role.
  repeated string policies = 11;

  //Name of the role.
  string role = 12;

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 13 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 14 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 15 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 16 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 17 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 18 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 19 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 20 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 21 [json_name = "token_type"];

  //The TTL period of tokens issued using this role, provided as the number of seconds.
  int64 ttl = 22;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 23;

  int32 count = 24;

  terraform.meta.MetaFields.ForEachEntry for_each = 25;

  string provider = 26;

  terraform.meta.Lifecycle lifecycle = 27;
}

//VaultAzureSecretBackend version is 0
message VaultAzureSecretBackend {
  //The client id for credentials to query the Azure APIs. Currently read permissions to query compute resources are required.
  string client_id = 1 [json_name = "client_id"];

  //The client secret for credentials to query the Azure APIs
  string client_secret = 2 [json_name = "client_secret"];

  //Human-friendly description of the mount for the backend.
  string description = 3;

  //The Azure cloud environment. Valid values: AzurePublicCloud, AzureUSGovernmentCloud, AzureChinaCloud, AzureGermanCloud.
  string environment = 4;

  string id = 5;

  //Path to mount the backend at.
  string path = 6;

  //The subscription id for the Azure Active Directory.
  string subscription_id = 7 [json_name = "subscription_id"];

  //The tenant id for the Azure Active Directory organization.
  string tenant_id = 8 [json_name = "tenant_id"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;
}

//VaultAzureSecretBackendRole version is 0
message VaultAzureSecretBackendRole {
  //Application Object ID for an existing service principal that will be used instead of creating dynamic service principals.
  string application_object_id = 1 [json_name = "application_object_id"];

  //Unique name of the auth backend to configure.
  string backend = 2;

  //Human-friendly description of the mount for the backend.
  string description = 3;

  string id = 4;

  //Human-friendly description of the mount for the backend.
  string max_ttl = 5 [json_name = "max_ttl"];

  //Name of the role to create
  string role = 6;

  //Human-friendly description of the mount for the backend.
  string ttl = 7;

  AzureRoles azure_roles = 8 [json_name = "azure_roles"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;

  message AzureRoles {
    string role_id = 1 [json_name = "role_id"];

    string role_name = 2 [json_name = "role_name"];

    string scope = 3;
  }
}

//VaultCertAuthBackendRole version is 1
message VaultCertAuthBackendRole {
  repeated string allowed_common_names = 1 [json_name = "allowed_common_names"];

  repeated string allowed_dns_sans = 2 [json_name = "allowed_dns_sans"];

  repeated string allowed_email_sans = 3 [json_name = "allowed_email_sans"];

  repeated string allowed_names = 4 [json_name = "allowed_names"];

  repeated string allowed_organization_units = 5 [json_name = "allowed_organization_units"];

  repeated string allowed_uri_sans = 6 [json_name = "allowed_uri_sans"];

  string backend = 7;

  repeated string bound_cidrs = 8 [json_name = "bound_cidrs"];

  string certificate = 9;

  string display_name = 10 [json_name = "display_name"];

  string id = 11;

  string max_ttl = 12 [json_name = "max_ttl"];

  string name = 13;

  string period = 14;

  repeated string policies = 15;

  repeated string required_extensions = 16 [json_name = "required_extensions"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 17 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 18 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 19 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 20 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 21 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 22 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 23 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 24 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 25 [json_name = "token_type"];

  string ttl = 26;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 27;

  int32 count = 28;

  terraform.meta.MetaFields.ForEachEntry for_each = 29;

  string provider = 30;

  terraform.meta.Lifecycle lifecycle = 31;
}

//VaultConsulSecretBackend version is 0
message VaultConsulSecretBackend {
  //Specifies the address of the Consul instance, provided as "host:port" like "127.0.0.1:8500".
  string address = 1;

  //Default lease duration for secrets in seconds
  int64 default_lease_ttl_seconds = 2 [json_name = "default_lease_ttl_seconds"];

  //Human-friendly description of the mount for the backend.
  string description = 3;

  string id = 4;

  //Maximum possible lease duration for secrets in seconds
  int64 max_lease_ttl_seconds = 5 [json_name = "max_lease_ttl_seconds"];

  //Unique name of the Vault Consul mount to configure
  string path = 6;

  //Specifies the URL scheme to use. Defaults to "http".
  string scheme = 7;

  //Specifies the Consul ACL token to use. This must be a management type token.
  string token = 8;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;
}

//VaultConsulSecretBackendRole version is 0
message VaultConsulSecretBackendRole {
  //The path of the Consul Secret Backend the role belongs to.
  string backend = 1;

  string id = 2;

  //Indicates that the token should not be replicated globally and instead be local to the current datacenter.
  bool local = 3;

  //Maximum TTL for leases associated with this role, in seconds.
  int64 max_ttl = 4 [json_name = "max_ttl"];

  //The name of an existing role against which to create this Consul credential
  string name = 5;

  //The path of the Consul Secret Backend the role belongs to.
  string path = 6;

  //List of Consul policies to associate with this role
  repeated string policies = 7;

  //Specifies the type of token to create when using this role. Valid values are "client" or "management".
  string token_type = 8 [json_name = "token_type"];

  //Specifies the TTL for this role.
  int64 ttl = 9;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 10;

  int32 count = 11;

  terraform.meta.MetaFields.ForEachEntry for_each = 12;

  string provider = 13;

  terraform.meta.Lifecycle lifecycle = 14;
}

//VaultDatabaseSecretBackendConnection version is 0
message VaultDatabaseSecretBackendConnection {
  //A list of roles that are allowed to use this connection.
  repeated string allowed_roles = 1 [json_name = "allowed_roles"];

  //Unique name of the Vault mount to configure.
  string backend = 2;

  //A map of sensitive data to pass to the endpoint. Useful for templated connection strings.
  map<string, string> data = 3;

  string id = 4;

  //Name of the database connection.
  string name = 5;

  //A list of database statements to be executed to rotate the root user's credentials.
  repeated string root_rotation_statements = 6 [json_name = "root_rotation_statements"];

  //Specifies if the connection is verified during initial configuration.
  bool verify_connection = 7 [json_name = "verify_connection"];

  MysqlLegacy mysql_legacy = 8 [json_name = "mysql_legacy"];

  Cassandra cassandra = 9;

  Mysql mysql = 10;

  Mongodb mongodb = 11;

  Mongodbatlas mongodbatlas = 12;

  Mssql mssql = 13;

  MysqlAurora mysql_aurora = 14 [json_name = "mysql_aurora"];

  MysqlRds mysql_rds = 15 [json_name = "mysql_rds"];

  Oracle oracle = 16;

  Elasticsearch elasticsearch = 17;

  Hana hana = 18;

  Postgresql postgresql = 19;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 20;

  int32 count = 21;

  terraform.meta.MetaFields.ForEachEntry for_each = 22;

  string provider = 23;

  terraform.meta.Lifecycle lifecycle = 24;

  message MysqlLegacy {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message Cassandra {
    //The number of seconds to use as a connection timeout.
    int64 connect_timeout = 1 [json_name = "connect_timeout"];

    //Cassandra hosts to connect to.
    repeated string hosts = 2;

    //Whether to skip verification of the server certificate when using TLS.
    bool insecure_tls = 3 [json_name = "insecure_tls"];

    //The password to use when authenticating with Cassandra.
    string password = 4;

    //Concatenated PEM blocks containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
    string pem_bundle = 5 [json_name = "pem_bundle"];

    //Specifies JSON containing a certificate and private key; a certificate, private key, and issuing CA certificate; or just a CA certificate.
    string pem_json = 6 [json_name = "pem_json"];

    //The transport port to use to connect to Cassandra.
    int64 port = 7;

    //The CQL protocol version to use.
    int64 protocol_version = 8 [json_name = "protocol_version"];

    //Whether to use TLS when connecting to Cassandra.
    bool tls = 9;

    //The username to use when authenticating with Cassandra.
    string username = 10;
  }

  message Mysql {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message Mongodb {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message Mongodbatlas {
    //The Private Programmatic API Key used to connect with MongoDB Atlas API.
    string private_key = 1 [json_name = "private_key"];

    //The Project ID the Database User should be created within.
    string project_id = 2 [json_name = "project_id"];

    //The Public Programmatic API Key used to authenticate with the MongoDB Atlas API.
    string public_key = 3 [json_name = "public_key"];
  }

  message Mssql {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message MysqlAurora {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message MysqlRds {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message Oracle {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message Elasticsearch {
    //The password to be used in the connection URL
    string password = 1;

    //The URL for Elasticsearch's API
    string url = 2;

    //The username to be used in the connection URL
    string username = 3;
  }

  message Hana {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }

  message Postgresql {
    //Connection string to use to connect to the database.
    string connection_url = 1 [json_name = "connection_url"];

    //Maximum number of seconds a connection may be reused.
    int64 max_connection_lifetime = 2 [json_name = "max_connection_lifetime"];

    //Maximum number of idle connections to the database.
    int64 max_idle_connections = 3 [json_name = "max_idle_connections"];

    //Maximum number of open connections to the database.
    int64 max_open_connections = 4 [json_name = "max_open_connections"];
  }
}

//VaultDatabaseSecretBackendRole version is 0
message VaultDatabaseSecretBackendRole {
  //The path of the Database Secret Backend the role belongs to.
  string backend = 1;

  //Database statements to execute to create and configure a user.
  repeated string creation_statements = 2 [json_name = "creation_statements"];

  //Database connection to use for this role.
  string db_name = 3 [json_name = "db_name"];

  //Default TTL for leases associated with this role, in seconds.
  int64 default_ttl = 4 [json_name = "default_ttl"];

  string id = 5;

  //Maximum TTL for leases associated with this role, in seconds.
  int64 max_ttl = 6 [json_name = "max_ttl"];

  //Unique name for the role.
  string name = 7;

  //Database statements to execute to renew a user.
  repeated string renew_statements = 8 [json_name = "renew_statements"];

  //Database statements to execute to revoke a user.
  repeated string revocation_statements = 9 [json_name = "revocation_statements"];

  //Database statements to execute to rollback a create operation in the event of an error.
  repeated string rollback_statements = 10 [json_name = "rollback_statements"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 11;

  int32 count = 12;

  terraform.meta.MetaFields.ForEachEntry for_each = 13;

  string provider = 14;

  terraform.meta.Lifecycle lifecycle = 15;
}

//VaultDatabaseSecretBackendStaticRole version is 0
message VaultDatabaseSecretBackendStaticRole {
  //The path of the Database Secret Backend the role belongs to.
  string backend = 1;

  //Database connection to use for this role.
  string db_name = 2 [json_name = "db_name"];

  string id = 3;

  //Unique name for the static role.
  string name = 4;

  //The amount of time Vault should wait before rotating the password, in seconds.
  int64 rotation_period = 5 [json_name = "rotation_period"];

  //Database statements to execute to rotate the password for the configured database user.
  repeated string rotation_statements = 6 [json_name = "rotation_statements"];

  //The database username that this role corresponds to.
  string username = 7;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 8;

  int32 count = 9;

  terraform.meta.MetaFields.ForEachEntry for_each = 10;

  string provider = 11;

  terraform.meta.Lifecycle lifecycle = 12;
}

//VaultEgpPolicy version is 0
message VaultEgpPolicy {
  //Enforcement level of Sentinel policy. Can be one of: 'advisory', 'soft-mandatory' or 'hard-mandatory'
  string enforcement_level = 1 [json_name = "enforcement_level"];

  string id = 2;

  //Name of the policy
  string name = 3;

  //List of paths to which the policy will be applied
  repeated string paths = 4;

  //The policy document
  string policy = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultGcpAuthBackend version is 0
message VaultGcpAuthBackend {
  string client_email = 1 [json_name = "client_email"];

  string client_id = 2 [json_name = "client_id"];

  string credentials = 3;

  string description = 4;

  string id = 5;

  string path = 6;

  string private_key_id = 7 [json_name = "private_key_id"];

  string project_id = 8 [json_name = "project_id"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;
}

//VaultGcpAuthBackendRole version is 1
message VaultGcpAuthBackendRole {
  bool add_group_aliases = 1 [json_name = "add_group_aliases"];

  bool allow_gce_inference = 2 [json_name = "allow_gce_inference"];

  string backend = 3;

  repeated string bound_instance_groups = 4 [json_name = "bound_instance_groups"];

  repeated string bound_labels = 5 [json_name = "bound_labels"];

  repeated string bound_projects = 6 [json_name = "bound_projects"];

  repeated string bound_regions = 7 [json_name = "bound_regions"];

  repeated string bound_service_accounts = 8 [json_name = "bound_service_accounts"];

  repeated string bound_zones = 9 [json_name = "bound_zones"];

  string id = 10;

  string max_jwt_exp = 11 [json_name = "max_jwt_exp"];

  string max_ttl = 12 [json_name = "max_ttl"];

  string period = 13;

  repeated string policies = 14;

  string project_id = 15 [json_name = "project_id"];

  string role = 16;

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 17 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 18 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 19 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 20 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 21 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 22 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 23 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 24 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 25 [json_name = "token_type"];

  string ttl = 26;

  string type = 27;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 28;

  int32 count = 29;

  terraform.meta.MetaFields.ForEachEntry for_each = 30;

  string provider = 31;

  terraform.meta.Lifecycle lifecycle = 32;
}

//VaultGcpSecretBackend version is 0
message VaultGcpSecretBackend {
  //JSON-encoded credentials to use to connect to GCP
  string credentials = 1;

  //Default lease duration for secrets in seconds
  int64 default_lease_ttl_seconds = 2 [json_name = "default_lease_ttl_seconds"];

  //Human-friendly description of the mount for the backend.
  string description = 3;

  string id = 4;

  //Maximum possible lease duration for secrets in seconds
  int64 max_lease_ttl_seconds = 5 [json_name = "max_lease_ttl_seconds"];

  //Path to mount the backend at.
  string path = 6;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 7;

  int32 count = 8;

  terraform.meta.MetaFields.ForEachEntry for_each = 9;

  string provider = 10;

  terraform.meta.Lifecycle lifecycle = 11;
}

//VaultGcpSecretRoleset version is 0
message VaultGcpSecretRoleset {
  //Path where the GCP secrets engine is mounted.
  string backend = 1;

  string id = 2;

  //Name of the GCP project that this roleset's service account will belong to.
  string project = 3;

  //Name of the RoleSet to create
  string roleset = 4;

  //Type of secret generated for this role set. Defaults to `access_token`. Accepted values: `access_token`, `service_account_key`
  string secret_type = 5 [json_name = "secret_type"];

  //Email of the service account created by Vault for this Roleset
  string service_account_email = 6 [json_name = "service_account_email"];

  //List of OAuth scopes to assign to `access_token` secrets generated under this role set (`access_token` role sets only)
  repeated string token_scopes = 7 [json_name = "token_scopes"];

  Binding binding = 8;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;

  message Binding {
    //Resource name
    string resource = 1;

    //List of roles to apply to the resource
    repeated string roles = 2;
  }
}

//VaultGenericEndpoint version is 1
message VaultGenericEndpoint {
  //JSON-encoded data to write.
  string data_json = 1 [json_name = "data_json"];

  //Don't attempt to delete the path from Vault if true
  bool disable_delete = 2 [json_name = "disable_delete"];

  //Don't attempt to read the path from Vault if true; drift won't be detected
  bool disable_read = 3 [json_name = "disable_read"];

  string id = 4;

  //When reading, disregard fields not present in data_json
  bool ignore_absent_fields = 5 [json_name = "ignore_absent_fields"];

  //Full path where to the endpoint that will be written
  string path = 6;

  //Map of strings returned by write operation
  map<string, string> write_data = 7;

  //JSON data returned by write operation
  string write_data_json = 8 [json_name = "write_data_json"];

  //Top-level fields returned by write to persist in state
  repeated string write_fields = 9 [json_name = "write_fields"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 10;

  int32 count = 11;

  terraform.meta.MetaFields.ForEachEntry for_each = 12;

  string provider = 13;

  terraform.meta.Lifecycle lifecycle = 14;
}

//VaultGenericSecret version is 1
message VaultGenericSecret {
  //Attempt to read the token from Vault if true; if false, drift won't be detected.
  bool allow_read = 1 [json_name = "allow_read"];

  //Map of strings read from Vault.
  map<string, string> data = 2;

  //JSON-encoded secret data to write.
  string data_json = 3 [json_name = "data_json"];

  //Don't attempt to read the token from Vault if true; drift won't be detected.
  bool disable_read = 4 [json_name = "disable_read"];

  string id = 5;

  //Full path where the generic secret will be written.
  string path = 6;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 7;

  int32 count = 8;

  terraform.meta.MetaFields.ForEachEntry for_each = 9;

  string provider = 10;

  terraform.meta.Lifecycle lifecycle = 11;
}

//VaultGithubAuthBackend version is 0
message VaultGithubAuthBackend {
  //The mount accessor related to the auth mount.
  string accessor = 1;

  //The API endpoint to use. Useful if you are running GitHub Enterprise or an API-compatible authentication server.
  string base_url = 2 [json_name = "base_url"];

  //Specifies the description of the mount. This overrides the current stored value, if any.
  string description = 3;

  string id = 4;

  //Maximum duration after which authentication will be expired, in seconds.
  string max_ttl = 5 [json_name = "max_ttl"];

  //The organization users must be part of.
  string organization = 6;

  //Path where the auth backend is mounted
  string path = 7;

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 8 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 9 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 10 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 11 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 12 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 13 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 14 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 15 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 16 [json_name = "token_type"];

  //Duration after which authentication will be expired, in seconds.
  string ttl = 17;

  repeated Tune tune = 18;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 19;

  int32 count = 20;

  terraform.meta.MetaFields.ForEachEntry for_each = 21;

  string provider = 22;

  terraform.meta.Lifecycle lifecycle = 23;

  message Tune {
    //allowed_response_headers: list of string
    repeated string allowed_response_headers = 1 [json_name = "allowed_response_headers"];

    //audit_non_hmac_request_keys: list of string
    repeated string audit_non_hmac_request_keys = 2 [json_name = "audit_non_hmac_request_keys"];

    //audit_non_hmac_response_keys: list of string
    repeated string audit_non_hmac_response_keys = 3 [json_name = "audit_non_hmac_response_keys"];

    //default_lease_ttl: string
    string default_lease_ttl = 4 [json_name = "default_lease_ttl"];

    //listing_visibility: string
    string listing_visibility = 5 [json_name = "listing_visibility"];

    //max_lease_ttl: string
    string max_lease_ttl = 6 [json_name = "max_lease_ttl"];

    //passthrough_request_headers: list of string
    repeated string passthrough_request_headers = 7 [json_name = "passthrough_request_headers"];

    //token_type: string
    string token_type = 8 [json_name = "token_type"];
  }
}

//VaultGithubTeam version is 0
message VaultGithubTeam {
  //Auth backend to which team mapping will be congigured.
  string backend = 1;

  string id = 2;

  //Policies to be assigned to this team.
  repeated string policies = 3;

  //GitHub team name in "slugified" format.
  string team = 4;

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 5 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 6 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 7 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 8 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 9 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 10 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 11 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 12 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 13 [json_name = "token_type"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 14;

  int32 count = 15;

  terraform.meta.MetaFields.ForEachEntry for_each = 16;

  string provider = 17;

  terraform.meta.Lifecycle lifecycle = 18;
}

//VaultGithubUser version is 0
message VaultGithubUser {
  //Auth backend to which user mapping will be congigured.
  string backend = 1;

  string id = 2;

  //Policies to be assigned to this user.
  repeated string policies = 3;

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 4 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 5 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 6 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 7 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 8 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 9 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 10 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 11 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 12 [json_name = "token_type"];

  //GitHub user name.
  string user = 13;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 14;

  int32 count = 15;

  terraform.meta.MetaFields.ForEachEntry for_each = 16;

  string provider = 17;

  terraform.meta.Lifecycle lifecycle = 18;
}

//VaultIdentityEntity version is 0
message VaultIdentityEntity {
  //Whether the entity is disabled. Disabled entities' associated tokens cannot be used, but are not revoked.
  bool disabled = 1;

  //Manage policies externally through `vault_identity_entity_policies`.
  bool external_policies = 2 [json_name = "external_policies"];

  string id = 3;

  //Metadata to be associated with the entity.
  map<string, string> metadata = 4;

  //Name of the entity.
  string name = 5;

  //Policies to be tied to the entity.
  repeated string policies = 6;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 7;

  int32 count = 8;

  terraform.meta.MetaFields.ForEachEntry for_each = 9;

  string provider = 10;

  terraform.meta.Lifecycle lifecycle = 11;
}

//VaultIdentityEntityAlias version is 0
message VaultIdentityEntityAlias {
  //ID of the entity to which this is an alias.
  string canonical_id = 1 [json_name = "canonical_id"];

  string id = 2;

  //Mount accessor to which this alias belongs toMount accessor to which this alias belongs to.
  string mount_accessor = 3 [json_name = "mount_accessor"];

  //Name of the entity alias.
  string name = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultIdentityEntityPolicies version is 0
message VaultIdentityEntityPolicies {
  //ID of the entity.
  string entity_id = 1 [json_name = "entity_id"];

  //Name of the entity.
  string entity_name = 2 [json_name = "entity_name"];

  //Should the resource manage policies exclusively
  bool exclusive = 3;

  string id = 4;

  //Policies to be tied to the entity.
  repeated string policies = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultIdentityGroup version is 0
message VaultIdentityGroup {
  //Manage member entities externally through `vault_identity_group_policies_member_entity_ids`
  bool external_member_entity_ids = 1 [json_name = "external_member_entity_ids"];

  //Manage policies externally through `vault_identity_group_policies`, allows using group ID in assigned policies.
  bool external_policies = 2 [json_name = "external_policies"];

  string id = 3;

  //Entity IDs to be assigned as group members.
  repeated string member_entity_ids = 4 [json_name = "member_entity_ids"];

  //Group IDs to be assigned as group members.
  repeated string member_group_ids = 5 [json_name = "member_group_ids"];

  //Metadata to be associated with the group.
  map<string, string> metadata = 6;

  //Name of the group.
  string name = 7;

  //Policies to be tied to the group.
  repeated string policies = 8;

  //Type of the group, internal or external. Defaults to internal.
  string type = 9;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 10;

  int32 count = 11;

  terraform.meta.MetaFields.ForEachEntry for_each = 12;

  string provider = 13;

  terraform.meta.Lifecycle lifecycle = 14;
}

//VaultIdentityGroupAlias version is 0
message VaultIdentityGroupAlias {
  //ID of the group to which this is an alias.
  string canonical_id = 1 [json_name = "canonical_id"];

  string id = 2;

  //Mount accessor to which this alias belongs to.
  string mount_accessor = 3 [json_name = "mount_accessor"];

  //Name of the group alias.
  string name = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultIdentityGroupMemberEntityIds version is 0
message VaultIdentityGroupMemberEntityIds {
  //Should the resource manage member entity ids exclusively? Beware of race conditions when disabling exclusive management
  bool exclusive = 1;

  //ID of the group.
  string group_id = 2 [json_name = "group_id"];

  //Name of the group.
  string group_name = 3 [json_name = "group_name"];

  string id = 4;

  //Entity IDs to be assigned as group members.
  repeated string member_entity_ids = 5 [json_name = "member_entity_ids"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultIdentityGroupPolicies version is 0
message VaultIdentityGroupPolicies {
  //Should the resource manage policies exclusively? Beware of race conditions when disabling exclusive management
  bool exclusive = 1;

  //ID of the group.
  string group_id = 2 [json_name = "group_id"];

  //Name of the group.
  string group_name = 3 [json_name = "group_name"];

  string id = 4;

  //Policies to be tied to the group.
  repeated string policies = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultIdentityOidc version is 0
message VaultIdentityOidc {
  string id = 1;

  //Issuer URL to be used in the iss claim of the token. If not set, Vault's api_addr will be used. The issuer is a case sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components, but no query or fragment components.
  string issuer = 2;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 3;

  int32 count = 4;

  terraform.meta.MetaFields.ForEachEntry for_each = 5;

  string provider = 6;

  terraform.meta.Lifecycle lifecycle = 7;
}

//VaultIdentityOidcKey version is 0
message VaultIdentityOidcKey {
  //Signing algorithm to use. Signing algorithm to use. Allowed values are: RS256 (default), RS384, RS512, ES256, ES384, ES512, EdDSA.
  string algorithm = 1;

  //Array of role client ids allowed to use this key for signing. If empty, no roles are allowed. If "*", all roles are allowed.
  repeated string allowed_client_ids = 2 [json_name = "allowed_client_ids"];

  string id = 3;

  //Name of the key.
  string name = 4;

  //How often to generate a new signing key in number of seconds
  int64 rotation_period = 5 [json_name = "rotation_period"];

  //Controls how long the public portion of a signing key will be available for verification after being rotated in seconds.
  int64 verification_ttl = 6 [json_name = "verification_ttl"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 7;

  int32 count = 8;

  terraform.meta.MetaFields.ForEachEntry for_each = 9;

  string provider = 10;

  terraform.meta.Lifecycle lifecycle = 11;
}

//VaultIdentityOidcKeyAllowedClientId version is 0
message VaultIdentityOidcKeyAllowedClientId {
  //Role Client ID allowed to use the key for signing.
  string allowed_client_id = 1 [json_name = "allowed_client_id"];

  string id = 2;

  //Name of the key.
  string key_name = 3 [json_name = "key_name"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 4;

  int32 count = 5;

  terraform.meta.MetaFields.ForEachEntry for_each = 6;

  string provider = 7;

  terraform.meta.Lifecycle lifecycle = 8;
}

//VaultIdentityOidcRole version is 0
message VaultIdentityOidcRole {
  //The value that will be included in the `aud` field of all the OIDC identity tokens issued by this role
  string client_id = 1 [json_name = "client_id"];

  string id = 2;

  //A configured named key, the key must already exist.
  string key = 3;

  //Name of the role.
  string name = 4;

  //The template string to use for generating tokens. This may be in string-ified JSON or base64 format.
  string template = 5;

  //TTL of the tokens generated against the role in number of seconds.
  int64 ttl = 6;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 7;

  int32 count = 8;

  terraform.meta.MetaFields.ForEachEntry for_each = 9;

  string provider = 10;

  terraform.meta.Lifecycle lifecycle = 11;
}

//VaultJwtAuthBackend version is 0
message VaultJwtAuthBackend {
  //The accessor of the JWT auth backend
  string accessor = 1;

  //The value against which to match the iss claim in a JWT
  string bound_issuer = 2 [json_name = "bound_issuer"];

  //The default role to use if none is provided during login
  string default_role = 3 [json_name = "default_role"];

  //The description of the auth backend
  string description = 4;

  string id = 5;

  //The CA certificate or chain of certificates, in PEM format, to use to validate connections to the JWKS URL. If not set, system certificates are used.
  string jwks_ca_pem = 6 [json_name = "jwks_ca_pem"];

  //JWKS URL to use to authenticate signatures. Cannot be used with 'oidc_discovery_url' or 'jwt_validation_pubkeys'.
  string jwks_url = 7 [json_name = "jwks_url"];

  //A list of supported signing algorithms. Defaults to [RS256]
  repeated string jwt_supported_algs = 8 [json_name = "jwt_supported_algs"];

  //A list of PEM-encoded public keys to use to authenticate signatures locally. Cannot be used with 'jwks_url' or 'oidc_discovery_url'.
  repeated string jwt_validation_pubkeys = 9 [json_name = "jwt_validation_pubkeys"];

  //Client ID used for OIDC
  string oidc_client_id = 10 [json_name = "oidc_client_id"];

  //Client Secret used for OIDC
  string oidc_client_secret = 11 [json_name = "oidc_client_secret"];

  //The CA certificate or chain of certificates, in PEM format, to use to validate connections to the OIDC Discovery URL. If not set, system certificates are used
  string oidc_discovery_ca_pem = 12 [json_name = "oidc_discovery_ca_pem"];

  //The OIDC Discovery URL, without any .well-known component (base path). Cannot be used with 'jwks_url' or 'jwt_validation_pubkeys'.
  string oidc_discovery_url = 13 [json_name = "oidc_discovery_url"];

  //path to mount the backend
  string path = 14;

  repeated Tune tune = 15;

  //Type of backend. Can be either 'jwt' or 'oidc'
  string type = 16;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 17;

  int32 count = 18;

  terraform.meta.MetaFields.ForEachEntry for_each = 19;

  string provider = 20;

  terraform.meta.Lifecycle lifecycle = 21;

  message Tune {
    //allowed_response_headers: list of string
    repeated string allowed_response_headers = 1 [json_name = "allowed_response_headers"];

    //audit_non_hmac_request_keys: list of string
    repeated string audit_non_hmac_request_keys = 2 [json_name = "audit_non_hmac_request_keys"];

    //audit_non_hmac_response_keys: list of string
    repeated string audit_non_hmac_response_keys = 3 [json_name = "audit_non_hmac_response_keys"];

    //default_lease_ttl: string
    string default_lease_ttl = 4 [json_name = "default_lease_ttl"];

    //listing_visibility: string
    string listing_visibility = 5 [json_name = "listing_visibility"];

    //max_lease_ttl: string
    string max_lease_ttl = 6 [json_name = "max_lease_ttl"];

    //passthrough_request_headers: list of string
    repeated string passthrough_request_headers = 7 [json_name = "passthrough_request_headers"];

    //token_type: string
    string token_type = 8 [json_name = "token_type"];
  }
}

//VaultJwtAuthBackendRole version is 0
message VaultJwtAuthBackendRole {
  //The list of allowed values for redirect_uri during OIDC logins.
  repeated string allowed_redirect_uris = 1 [json_name = "allowed_redirect_uris"];

  //Unique name of the auth backend to configure.
  string backend = 2;

  //List of aud claims to match against. Any match is sufficient.
  repeated string bound_audiences = 3 [json_name = "bound_audiences"];

  //List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.
  repeated string bound_cidrs = 4 [json_name = "bound_cidrs"];

  //Map of claims/values to match against. The expected value may be a single string or a comma-separated string list.
  map<string, string> bound_claims = 5;

  //If set, requires that the sub claim matches this value.
  string bound_subject = 6 [json_name = "bound_subject"];

  //Map of claims (keys) to be copied to specified metadata fields (values).
  map<string, string> claim_mappings = 7;

  //The amount of leeway to add to all claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
  int64 clock_skew_leeway = 8 [json_name = "clock_skew_leeway"];

  //The amount of leeway to add to expiration (exp) claims to account for clock skew, in seconds. Defaults to 60 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
  int64 expiration_leeway = 9 [json_name = "expiration_leeway"];

  //The claim to use to uniquely identify the set of groups to which the user belongs; this will be used as the names for the Identity group aliases created due to a successful login. The claim value must be a list of strings.
  string groups_claim = 10 [json_name = "groups_claim"];

  //A pattern of delimiters used to allow the groups_claim to live outside of the top-level JWT structure. For instance, a groups_claim of meta/user.name/groups with this field set to // will expect nested structures named meta, user.name, and groups. If this field was set to /./ the groups information would expect to be via nested structures of meta, user, name, and groups.
  string groups_claim_delimiter_pattern = 11 [json_name = "groups_claim_delimiter_pattern"];

  string id = 12;

  //Number of seconds after which issued tokens can no longer be renewed.
  int64 max_ttl = 13 [json_name = "max_ttl"];

  //The amount of leeway to add to not before (nbf) claims to account for clock skew, in seconds. Defaults to 150 seconds if set to 0 and can be disabled if set to -1. Only applicable with 'jwt' roles.
  int64 not_before_leeway = 14 [json_name = "not_before_leeway"];

  //Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.
  int64 num_uses = 15 [json_name = "num_uses"];

  //List of OIDC scopes to be used with an OIDC role. The standard scope "openid" is automatically included and need not be specified.
  repeated string oidc_scopes = 16 [json_name = "oidc_scopes"];

  //Number of seconds to set the TTL to for issued tokens upon renewal. Makes the token a periodic token, which will never expire as long as it is renewed before the TTL each period.
  int64 period = 17;

  //Policies to be set on tokens issued using this role.
  repeated string policies = 18;

  //Name of the role.
  string role_name = 19 [json_name = "role_name"];

  //Type of role, either "oidc" (default) or "jwt"
  string role_type = 20 [json_name = "role_type"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 21 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 22 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 23 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 24 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 25 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 26 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 27 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 28 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 29 [json_name = "token_type"];

  //Default number of seconds to set as the TTL for issued tokens and at renewal time.
  int64 ttl = 30;

  //The claim to use to uniquely identify the user; this will be used as the name for the Identity entity alias created due to a successful login.
  string user_claim = 31 [json_name = "user_claim"];

  //Log received OIDC tokens and claims when debug-level logging is active. Not recommended in production since sensitive information may be present in OIDC responses.
  bool verbose_oidc_logging = 32 [json_name = "verbose_oidc_logging"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 33;

  int32 count = 34;

  terraform.meta.MetaFields.ForEachEntry for_each = 35;

  string provider = 36;

  terraform.meta.Lifecycle lifecycle = 37;
}

//VaultKubernetesAuthBackendConfig version is 0
message VaultKubernetesAuthBackendConfig {
  //Unique name of the kubernetes backend to configure.
  string backend = 1;

  string id = 2;

  //Optional JWT issuer. If no issuer is specified, kubernetes.io/serviceaccount will be used as the default issuer.
  string issuer = 3;

  //PEM encoded CA cert for use by the TLS client used to talk with the Kubernetes API.
  string kubernetes_ca_cert = 4 [json_name = "kubernetes_ca_cert"];

  //Host must be a host string, a host:port pair, or a URL to the base of the Kubernetes API server.
  string kubernetes_host = 5 [json_name = "kubernetes_host"];

  //Optional list of PEM-formatted public keys or certificates used to verify the signatures of Kubernetes service account JWTs. If a certificate is given, its public key will be extracted. Not every installation of Kubernetes exposes these keys.
  repeated string pem_keys = 6 [json_name = "pem_keys"];

  //A service account JWT used to access the TokenReview API to validate other JWTs during login. If not set the JWT used for login will be used to access the API.
  string token_reviewer_jwt = 7 [json_name = "token_reviewer_jwt"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 8;

  int32 count = 9;

  terraform.meta.MetaFields.ForEachEntry for_each = 10;

  string provider = 11;

  terraform.meta.Lifecycle lifecycle = 12;
}

//VaultKubernetesAuthBackendRole version is 0
message VaultKubernetesAuthBackendRole {
  //Optional Audience claim to verify in the JWT.
  string audience = 1;

  //Unique name of the kubernetes backend to configure.
  string backend = 2;

  //List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.
  repeated string bound_cidrs = 3 [json_name = "bound_cidrs"];

  //List of service account names able to access this role. If set to `["*"]` all names are allowed, both this and bound_service_account_namespaces can not be "*".
  repeated string bound_service_account_names = 4 [json_name = "bound_service_account_names"];

  //List of namespaces allowed to access this role. If set to `["*"]` all namespaces are allowed, both this and bound_service_account_names can not be set to "*".
  repeated string bound_service_account_namespaces = 5 [json_name = "bound_service_account_namespaces"];

  string id = 6;

  //Number of seconds after which issued tokens can no longer be renewed.
  int64 max_ttl = 7 [json_name = "max_ttl"];

  //Number of times issued tokens can be used. Setting this to 0 or leaving it unset means unlimited uses.
  int64 num_uses = 8 [json_name = "num_uses"];

  //Number of seconds to set the TTL to for issued tokens upon renewal. Makes the token a periodic token, which will never expire as long as it is renewed before the TTL each period.
  int64 period = 9;

  //Policies to be set on tokens issued using this role.
  repeated string policies = 10;

  //Name of the role.
  string role_name = 11 [json_name = "role_name"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 12 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 13 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 14 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 15 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 16 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 17 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 18 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 19 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 20 [json_name = "token_type"];

  //Default number of seconds to set as the TTL for issued tokens and at renewal time.
  int64 ttl = 21;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 22;

  int32 count = 23;

  terraform.meta.MetaFields.ForEachEntry for_each = 24;

  string provider = 25;

  terraform.meta.Lifecycle lifecycle = 26;
}

//VaultLdapAuthBackend version is 1
message VaultLdapAuthBackend {
  //The accessor of the LDAP auth backend
  string accessor = 1;

  string binddn = 2;

  string bindpass = 3;

  string certificate = 4;

  bool deny_null_bind = 5 [json_name = "deny_null_bind"];

  string description = 6;

  bool discoverdn = 7;

  string groupattr = 8;

  string groupdn = 9;

  string groupfilter = 10;

  string id = 11;

  bool insecure_tls = 12 [json_name = "insecure_tls"];

  string path = 13;

  bool starttls = 14;

  string tls_max_version = 15 [json_name = "tls_max_version"];

  string tls_min_version = 16 [json_name = "tls_min_version"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 17 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 18 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 19 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 20 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 21 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 22 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 23 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 24 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 25 [json_name = "token_type"];

  string upndomain = 26;

  string url = 27;

  bool use_token_groups = 28 [json_name = "use_token_groups"];

  string userattr = 29;

  string userdn = 30;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 31;

  int32 count = 32;

  terraform.meta.MetaFields.ForEachEntry for_each = 33;

  string provider = 34;

  terraform.meta.Lifecycle lifecycle = 35;
}

//VaultLdapAuthBackendGroup version is 1
message VaultLdapAuthBackendGroup {
  string backend = 1;

  string groupname = 2;

  string id = 3;

  repeated string policies = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultLdapAuthBackendUser version is 1
message VaultLdapAuthBackendUser {
  string backend = 1;

  repeated string groups = 2;

  string id = 3;

  repeated string policies = 4;

  string username = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultMfaDuo version is 0
message VaultMfaDuo {
  //API hostname for Duo.
  string api_hostname = 1 [json_name = "api_hostname"];

  string id = 2;

  //Integration key for Duo.
  string integration_key = 3 [json_name = "integration_key"];

  //The mount to tie this method to for use in automatic mappings. The mapping will use the Name field of Aliases associated with this mount as the username in the mapping.
  string mount_accessor = 4 [json_name = "mount_accessor"];

  //Name of the MFA method.
  string name = 5;

  //Push information for Duo.
  string push_info = 6 [json_name = "push_info"];

  //Secret key for Duo.
  string secret_key = 7 [json_name = "secret_key"];

  //A format string for mapping Identity names to MFA method names. Values to substitute should be placed in `{{}}`.
  string username_format = 8 [json_name = "username_format"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 9;

  int32 count = 10;

  terraform.meta.MetaFields.ForEachEntry for_each = 11;

  string provider = 12;

  terraform.meta.Lifecycle lifecycle = 13;
}

//VaultMount version is 0
message VaultMount {
  //Accessor of the mount
  string accessor = 1;

  //Default lease duration for tokens and secrets in seconds
  int64 default_lease_ttl_seconds = 2 [json_name = "default_lease_ttl_seconds"];

  //Human-friendly description of the mount
  string description = 3;

  //Enable the secrets engine to access Vault's external entropy source
  bool external_entropy_access = 4 [json_name = "external_entropy_access"];

  string id = 5;

  //Local mount flag that can be explicitly set to true to enforce local mount in HA environment
  bool local = 6;

  //Maximum possible lease duration for tokens and secrets in seconds
  int64 max_lease_ttl_seconds = 7 [json_name = "max_lease_ttl_seconds"];

  //Specifies mount type specific options that are passed to the backend
  map<string, string> options = 8;

  //Where the secret backend will be mounted
  string path = 9;

  //Enable seal wrapping for the mount, causing values stored by the mount to be wrapped by the seal's encryption capability
  bool seal_wrap = 10 [json_name = "seal_wrap"];

  //Type of the backend, such as 'aws'
  string type = 11;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 12;

  int32 count = 13;

  terraform.meta.MetaFields.ForEachEntry for_each = 14;

  string provider = 15;

  terraform.meta.Lifecycle lifecycle = 16;
}

//VaultNamespace version is 0
message VaultNamespace {
  string id = 1;

  //ID of the namepsace.
  string namespace_id = 2 [json_name = "namespace_id"];

  //Path of the namespace.
  string path = 3;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 4;

  int32 count = 5;

  terraform.meta.MetaFields.ForEachEntry for_each = 6;

  string provider = 7;

  terraform.meta.Lifecycle lifecycle = 8;
}

//VaultOktaAuthBackend version is 0
message VaultOktaAuthBackend {
  //The mount accessor related to the auth mount.
  string accessor = 1;

  //The Okta url. Examples: oktapreview.com, okta.com (default)
  string base_url = 2 [json_name = "base_url"];

  //When true, requests by Okta for a MFA check will be bypassed. This also disallows certain status checks on the account, such as whether the password is expired.
  bool bypass_okta_mfa = 3 [json_name = "bypass_okta_mfa"];

  //The description of the auth backend
  string description = 4;

  repeated Group group = 5;

  string id = 6;

  //Maximum duration after which authentication will be expired
  string max_ttl = 7 [json_name = "max_ttl"];

  //The Okta organization. This will be the first part of the url https://XXX.okta.com.
  string organization = 8;

  //path to mount the backend
  string path = 9;

  //The Okta API token. This is required to query Okta for user group membership. If this is not supplied only locally configured groups will be enabled.
  string token = 10;

  //Duration after which authentication will be expired
  string ttl = 11;

  repeated User user = 12;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 13;

  int32 count = 14;

  terraform.meta.MetaFields.ForEachEntry for_each = 15;

  string provider = 16;

  terraform.meta.Lifecycle lifecycle = 17;

  message Group {
    //group_name: string
    string group_name = 1 [json_name = "group_name"];

    //policies: set of string
    repeated string policies = 2;
  }

  message User {
    //groups: set of string
    repeated string groups = 1;

    //policies: set of string
    repeated string policies = 2;

    //username: string
    string username = 3;
  }
}

//VaultOktaAuthBackendGroup version is 0
message VaultOktaAuthBackendGroup {
  //Name of the Okta group
  string group_name = 1 [json_name = "group_name"];

  string id = 2;

  //Path to the Okta auth backend
  string path = 3;

  //Policies to associate with this group
  repeated string policies = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultOktaAuthBackendUser version is 0
message VaultOktaAuthBackendUser {
  //Groups within the Okta auth backend to associate with this user
  repeated string groups = 1;

  string id = 2;

  //Path to the Okta auth backend
  string path = 3;

  //Policies to associate with this user
  repeated string policies = 4;

  //Name of the user within Okta
  string username = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultPkiSecretBackend version is 0
message VaultPkiSecretBackend {
  //Default lease duration for tokens and secrets in seconds
  int64 default_lease_ttl_seconds = 1 [json_name = "default_lease_ttl_seconds"];

  //Human-friendly description of the mount for the backend.
  string description = 2;

  string id = 3;

  //Maximum possible lease duration for tokens and secrets in seconds
  int64 max_lease_ttl_seconds = 4 [json_name = "max_lease_ttl_seconds"];

  //Path to mount the backend at.
  string path = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultPkiSecretBackendCert version is 0
message VaultPkiSecretBackendCert {
  //List of alternative names.
  repeated string alt_names = 1 [json_name = "alt_names"];

  //If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining
  bool auto_renew = 2 [json_name = "auto_renew"];

  //The PKI secret backend the resource belongs to.
  string backend = 3;

  //The CA chain.
  string ca_chain = 4 [json_name = "ca_chain"];

  //The certicate.
  string certificate = 5;

  //CN of the certificate to create.
  string common_name = 6 [json_name = "common_name"];

  //Flag to exclude CN from SANs.
  bool exclude_cn_from_sans = 7 [json_name = "exclude_cn_from_sans"];

  //The certificate expiration.
  int64 expiration = 8;

  //The format of data.
  string format = 9;

  string id = 10;

  //List of alternative IPs.
  repeated string ip_sans = 11 [json_name = "ip_sans"];

  //The issuing CA.
  string issuing_ca = 12 [json_name = "issuing_ca"];

  //Generate a new certificate when the expiration is within this number of seconds
  int64 min_seconds_remaining = 13 [json_name = "min_seconds_remaining"];

  //Name of the role to create the certificate against.
  string name = 14;

  //List of other SANs.
  repeated string other_sans = 15 [json_name = "other_sans"];

  //The private key.
  string private_key = 16 [json_name = "private_key"];

  //The private key format.
  string private_key_format = 17 [json_name = "private_key_format"];

  //The private key type.
  string private_key_type = 18 [json_name = "private_key_type"];

  //The serial number.
  string serial_number = 19 [json_name = "serial_number"];

  //Time to leave.
  string ttl = 20;

  //List of alternative URIs.
  repeated string uri_sans = 21 [json_name = "uri_sans"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 22;

  int32 count = 23;

  terraform.meta.MetaFields.ForEachEntry for_each = 24;

  string provider = 25;

  terraform.meta.Lifecycle lifecycle = 26;
}

//VaultPkiSecretBackendConfigCa version is 0
message VaultPkiSecretBackendConfigCa {
  //The PKI secret backend the resource belongs to.
  string backend = 1;

  string id = 2;

  //The key and certificate PEM bundle.
  string pem_bundle = 3 [json_name = "pem_bundle"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 4;

  int32 count = 5;

  terraform.meta.MetaFields.ForEachEntry for_each = 6;

  string provider = 7;

  terraform.meta.Lifecycle lifecycle = 8;
}

//VaultPkiSecretBackendConfigUrls version is 0
message VaultPkiSecretBackendConfigUrls {
  //The path of the PKI secret backend the resource belongs to.
  string backend = 1;

  //Specifies the URL values for the CRL Distribution Points field.
  repeated string crl_distribution_points = 2 [json_name = "crl_distribution_points"];

  string id = 3;

  //Specifies the URL values for the Issuing Certificate field.
  repeated string issuing_certificates = 4 [json_name = "issuing_certificates"];

  //Specifies the URL values for the OCSP Servers field.
  repeated string ocsp_servers = 5 [json_name = "ocsp_servers"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultPkiSecretBackendCrlConfig version is 0
message VaultPkiSecretBackendCrlConfig {
  //The path of the PKI secret backend the resource belongs to.
  string backend = 1;

  //Disables or enables CRL building
  bool disable = 2;

  //Specifies the time until expiration.
  string expiry = 3;

  string id = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultPkiSecretBackendIntermediateCertRequest version is 0
message VaultPkiSecretBackendIntermediateCertRequest {
  //List of alternative names.
  repeated string alt_names = 1 [json_name = "alt_names"];

  //The PKI secret backend the resource belongs to.
  string backend = 2;

  //CN of intermediate to create.
  string common_name = 3 [json_name = "common_name"];

  //The country.
  string country = 4;

  //The CSR.
  string csr = 5;

  //Flag to exclude CN from SANs.
  bool exclude_cn_from_sans = 6 [json_name = "exclude_cn_from_sans"];

  //The format of data.
  string format = 7;

  string id = 8;

  //List of alternative IPs.
  repeated string ip_sans = 9 [json_name = "ip_sans"];

  //The number of bits to use.
  int64 key_bits = 10 [json_name = "key_bits"];

  //The desired key type.
  string key_type = 11 [json_name = "key_type"];

  //The locality.
  string locality = 12;

  //The organization.
  string organization = 13;

  //List of other SANs.
  repeated string other_sans = 14 [json_name = "other_sans"];

  //The organization unit.
  string ou = 15;

  //The postal code.
  string postal_code = 16 [json_name = "postal_code"];

  //The private key.
  string private_key = 17 [json_name = "private_key"];

  //The private key format.
  string private_key_format = 18 [json_name = "private_key_format"];

  //The private key type.
  string private_key_type = 19 [json_name = "private_key_type"];

  //The province.
  string province = 20;

  //The street address.
  string street_address = 21 [json_name = "street_address"];

  //Type of intermediate to create. Must be either "exported" or "internal".
  string type = 22;

  //List of alternative URIs.
  repeated string uri_sans = 23 [json_name = "uri_sans"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 24;

  int32 count = 25;

  terraform.meta.MetaFields.ForEachEntry for_each = 26;

  string provider = 27;

  terraform.meta.Lifecycle lifecycle = 28;
}

//VaultPkiSecretBackendIntermediateSetSigned version is 0
message VaultPkiSecretBackendIntermediateSetSigned {
  //The PKI secret backend the resource belongs to.
  string backend = 1;

  //The certificate.
  string certificate = 2;

  string id = 3;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 4;

  int32 count = 5;

  terraform.meta.MetaFields.ForEachEntry for_each = 6;

  string provider = 7;

  terraform.meta.Lifecycle lifecycle = 8;
}

//VaultPkiSecretBackendRole version is 0
message VaultPkiSecretBackendRole {
  //Flag to allow any name
  bool allow_any_name = 1 [json_name = "allow_any_name"];

  //Flag to allow certificates matching the actual domain.
  bool allow_bare_domains = 2 [json_name = "allow_bare_domains"];

  //Flag to allow names containing glob patterns.
  bool allow_glob_domains = 3 [json_name = "allow_glob_domains"];

  //Flag to allow IP SANs
  bool allow_ip_sans = 4 [json_name = "allow_ip_sans"];

  //Flag to allow certificates for localhost.
  bool allow_localhost = 5 [json_name = "allow_localhost"];

  //Flag to allow certificates matching subdomains.
  bool allow_subdomains = 6 [json_name = "allow_subdomains"];

  //The domains of the role.
  repeated string allowed_domains = 7 [json_name = "allowed_domains"];

  //Defines allowed custom SANs
  repeated string allowed_other_sans = 8 [json_name = "allowed_other_sans"];

  //Defines allowed URI SANs
  repeated string allowed_uri_sans = 9 [json_name = "allowed_uri_sans"];

  //The path of the PKI secret backend the resource belongs to.
  string backend = 10;

  //Flag to mark basic constraints valid when issuing non-CA certificates.
  bool basic_constraints_valid_for_non_ca = 11 [json_name = "basic_constraints_valid_for_non_ca"];

  //Flag to specify certificates for client use.
  bool client_flag = 12 [json_name = "client_flag"];

  //Flag to specify certificates for code signing use.
  bool code_signing_flag = 13 [json_name = "code_signing_flag"];

  //The country of generated certificates.
  repeated string country = 14;

  //Flag to specify certificates for email protection use.
  bool email_protection_flag = 15 [json_name = "email_protection_flag"];

  //Flag to allow only valid host names
  bool enforce_hostnames = 16 [json_name = "enforce_hostnames"];

  //Specify the allowed extended key usage constraint on issued certificates.
  repeated string ext_key_usage = 17 [json_name = "ext_key_usage"];

  //Flag to generate leases with certificates.
  bool generate_lease = 18 [json_name = "generate_lease"];

  string id = 19;

  //The number of bits of generated keys.
  int64 key_bits = 20 [json_name = "key_bits"];

  //The type of generated keys.
  string key_type = 21 [json_name = "key_type"];

  //Specify the allowed key usage constraint on issued certificates.
  repeated string key_usage = 22 [json_name = "key_usage"];

  //The locality of generated certificates.
  repeated string locality = 23;

  //The maximum TTL.
  string max_ttl = 24 [json_name = "max_ttl"];

  //Unique name for the role.
  string name = 25;

  //Flag to not store certificates in the storage backend.
  bool no_store = 26 [json_name = "no_store"];

  //Specifies the duration by which to backdate the NotBefore property.
  string not_before_duration = 27 [json_name = "not_before_duration"];

  //The organization of generated certificates.
  repeated string organization = 28;

  //The organization unit of generated certificates.
  repeated string ou = 29;

  //Specify the list of allowed policies IODs.
  repeated string policy_identifiers = 30 [json_name = "policy_identifiers"];

  //The postal code of generated certificates.
  repeated string postal_code = 31 [json_name = "postal_code"];

  //The province of generated certificates.
  repeated string province = 32;

  //Flag to force CN usage.
  bool require_cn = 33 [json_name = "require_cn"];

  //Flag to specify certificates for server use.
  bool server_flag = 34 [json_name = "server_flag"];

  //The street address of generated certificates.
  repeated string street_address = 35 [json_name = "street_address"];

  //The TTL.
  string ttl = 36;

  //Flag to use the CN in the CSR.
  bool use_csr_common_name = 37 [json_name = "use_csr_common_name"];

  //Flag to use the SANs in the CSR.
  bool use_csr_sans = 38 [json_name = "use_csr_sans"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 39;

  int32 count = 40;

  terraform.meta.MetaFields.ForEachEntry for_each = 41;

  string provider = 42;

  terraform.meta.Lifecycle lifecycle = 43;
}

//VaultPkiSecretBackendRootCert version is 0
message VaultPkiSecretBackendRootCert {
  //List of alternative names.
  repeated string alt_names = 1 [json_name = "alt_names"];

  //The PKI secret backend the resource belongs to.
  string backend = 2;

  //The certicate.
  string certificate = 3;

  //CN of intermediate to create.
  string common_name = 4 [json_name = "common_name"];

  //The country.
  string country = 5;

  //Flag to exclude CN from SANs.
  bool exclude_cn_from_sans = 6 [json_name = "exclude_cn_from_sans"];

  //The format of data.
  string format = 7;

  string id = 8;

  //List of alternative IPs.
  repeated string ip_sans = 9 [json_name = "ip_sans"];

  //The issuing CA.
  string issuing_ca = 10 [json_name = "issuing_ca"];

  //The number of bits to use.
  int64 key_bits = 11 [json_name = "key_bits"];

  //The desired key type.
  string key_type = 12 [json_name = "key_type"];

  //The locality.
  string locality = 13;

  //The maximum path length to encode in the generated certificate.
  int64 max_path_length = 14 [json_name = "max_path_length"];

  //The organization.
  string organization = 15;

  //List of other SANs.
  repeated string other_sans = 16 [json_name = "other_sans"];

  //The organization unit.
  string ou = 17;

  //List of domains for which certificates are allowed to be issued.
  repeated string permitted_dns_domains = 18 [json_name = "permitted_dns_domains"];

  //The postal code.
  string postal_code = 19 [json_name = "postal_code"];

  //The private key format.
  string private_key_format = 20 [json_name = "private_key_format"];

  //The province.
  string province = 21;

  //The serial number.
  string serial = 22;

  //The street address.
  string street_address = 23 [json_name = "street_address"];

  //Time to leave.
  string ttl = 24;

  //Type of intermediate to create. Must be either "exported" or "internal".
  string type = 25;

  //List of alterative URIs.
  repeated string uri_sans = 26 [json_name = "uri_sans"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 27;

  int32 count = 28;

  terraform.meta.MetaFields.ForEachEntry for_each = 29;

  string provider = 30;

  terraform.meta.Lifecycle lifecycle = 31;
}

//VaultPkiSecretBackendRootSignIntermediate version is 0
message VaultPkiSecretBackendRootSignIntermediate {
  //List of alternative names.
  repeated string alt_names = 1 [json_name = "alt_names"];

  //The PKI secret backend the resource belongs to.
  string backend = 2;

  //The CA chain.
  string ca_chain = 3 [json_name = "ca_chain"];

  //The certicate.
  string certificate = 4;

  //CN of intermediate to create.
  string common_name = 5 [json_name = "common_name"];

  //The country.
  string country = 6;

  //The CSR.
  string csr = 7;

  //Flag to exclude CN from SANs.
  bool exclude_cn_from_sans = 8 [json_name = "exclude_cn_from_sans"];

  //The format of data.
  string format = 9;

  string id = 10;

  //List of alternative IPs.
  repeated string ip_sans = 11 [json_name = "ip_sans"];

  //The issuing CA.
  string issuing_ca = 12 [json_name = "issuing_ca"];

  //The locality.
  string locality = 13;

  //The maximum path length to encode in the generated certificate.
  int64 max_path_length = 14 [json_name = "max_path_length"];

  //The organization.
  string organization = 15;

  //List of other SANs.
  repeated string other_sans = 16 [json_name = "other_sans"];

  //The organization unit.
  string ou = 17;

  //List of domains for which certificates are allowed to be issued.
  repeated string permitted_dns_domains = 18 [json_name = "permitted_dns_domains"];

  //The postal code.
  string postal_code = 19 [json_name = "postal_code"];

  //The province.
  string province = 20;

  //The serial number.
  string serial = 21;

  //The street address.
  string street_address = 22 [json_name = "street_address"];

  //Time to leave.
  string ttl = 23;

  //List of alterative URIs.
  repeated string uri_sans = 24 [json_name = "uri_sans"];

  //Preserve CSR values.
  bool use_csr_values = 25 [json_name = "use_csr_values"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 26;

  int32 count = 27;

  terraform.meta.MetaFields.ForEachEntry for_each = 28;

  string provider = 29;

  terraform.meta.Lifecycle lifecycle = 30;
}

//VaultPkiSecretBackendSign version is 0
message VaultPkiSecretBackendSign {
  //List of alternative names.
  repeated string alt_names = 1 [json_name = "alt_names"];

  //If enabled, a new certificate will be generated if the expiration is within min_seconds_remaining
  bool auto_renew = 2 [json_name = "auto_renew"];

  //The PKI secret backend the resource belongs to.
  string backend = 3;

  //The CA chain.
  repeated string ca_chain = 4 [json_name = "ca_chain"];

  //The certicate.
  string certificate = 5;

  //CN of intermediate to create.
  string common_name = 6 [json_name = "common_name"];

  //The CSR.
  string csr = 7;

  //Flag to exclude CN from SANs.
  bool exclude_cn_from_sans = 8 [json_name = "exclude_cn_from_sans"];

  //The certificate expiration.
  int64 expiration = 9;

  //The format of data.
  string format = 10;

  string id = 11;

  //List of alternative IPs.
  repeated string ip_sans = 12 [json_name = "ip_sans"];

  //The issuing CA.
  string issuing_ca = 13 [json_name = "issuing_ca"];

  //Generate a new certificate when the expiration is within this number of seconds
  int64 min_seconds_remaining = 14 [json_name = "min_seconds_remaining"];

  //Name of the role to create the certificate against.
  string name = 15;

  //List of other SANs.
  repeated string other_sans = 16 [json_name = "other_sans"];

  //The serial.
  string serial = 17;

  //Time to leave.
  string ttl = 18;

  //List of alterative URIs.
  repeated string uri_sans = 19 [json_name = "uri_sans"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 20;

  int32 count = 21;

  terraform.meta.MetaFields.ForEachEntry for_each = 22;

  string provider = 23;

  terraform.meta.Lifecycle lifecycle = 24;
}

//VaultPolicy version is 0
message VaultPolicy {
  string id = 1;

  //Name of the policy
  string name = 2;

  //The policy document
  string policy = 3;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 4;

  int32 count = 5;

  terraform.meta.MetaFields.ForEachEntry for_each = 6;

  string provider = 7;

  terraform.meta.Lifecycle lifecycle = 8;
}

//VaultQuotaRateLimit version is 0
message VaultQuotaRateLimit {
  string id = 1;

  //The name of the quota.
  string name = 2;

  //Path of the mount or namespace to apply the quota. A blank path configures a global rate limit quota.
  string path = 3;

  //The maximum number of requests at any given second to be allowed by the quota rule. The rate must be positive.
  int64 rate = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultRabbitmqSecretBackend version is 0
message VaultRabbitmqSecretBackend {
  //Specifies the RabbitMQ connection URI.
  string connection_uri = 1 [json_name = "connection_uri"];

  //Default lease duration for secrets in seconds
  int64 default_lease_ttl_seconds = 2 [json_name = "default_lease_ttl_seconds"];

  //Human-friendly description of the mount for the backend.
  string description = 3;

  string id = 4;

  //Maximum possible lease duration for secrets in seconds
  int64 max_lease_ttl_seconds = 5 [json_name = "max_lease_ttl_seconds"];

  //Specifies the RabbitMQ management administrator password
  string password = 6;

  //The path of the RabbitMQ Secret Backend where the connection should be configured
  string path = 7;

  //Specifies the RabbitMQ management administrator username
  string username = 8;

  //Specifies whether to verify connection URI, username, and password.
  bool verify_connection = 9 [json_name = "verify_connection"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 10;

  int32 count = 11;

  terraform.meta.MetaFields.ForEachEntry for_each = 12;

  string provider = 13;

  terraform.meta.Lifecycle lifecycle = 14;
}

//VaultRabbitmqSecretBackendRole version is 0
message VaultRabbitmqSecretBackendRole {
  //The path of the Rabbitmq Secret Backend the role belongs to.
  string backend = 1;

  string id = 2;

  //Unique name for the role.
  string name = 3;

  //Specifies a comma-separated RabbitMQ management tags.
  string tags = 4;

  Vhost vhost = 5;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;

  message Vhost {
    //The configure permissions for this vhost.
    string configure = 1;

    //The vhost to set permissions for.
    string host = 2;

    //The read permissions for this vhost.
    string read = 3;

    //The write permissions for this vhost.
    string write = 4;
  }
}

//VaultRgpPolicy version is 0
message VaultRgpPolicy {
  //Enforcement level of Sentinel policy. Can be one of: 'advisory', 'soft-mandatory' or 'hard-mandatory'
  string enforcement_level = 1 [json_name = "enforcement_level"];

  string id = 2;

  //Name of the policy
  string name = 3;

  //The policy document
  string policy = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultSshSecretBackendCa version is 0
message VaultSshSecretBackendCa {
  //The path of the SSH Secret Backend where the CA should be configured
  string backend = 1;

  //Whether Vault should generate the signing key pair internally.
  bool generate_signing_key = 2 [json_name = "generate_signing_key"];

  string id = 3;

  //Private key part the SSH CA key pair; required if generate_signing_key is false.
  string private_key = 4 [json_name = "private_key"];

  //Public key part the SSH CA key pair; required if generate_signing_key is false.
  string public_key = 5 [json_name = "public_key"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 6;

  int32 count = 7;

  terraform.meta.MetaFields.ForEachEntry for_each = 8;

  string provider = 9;

  terraform.meta.Lifecycle lifecycle = 10;
}

//VaultSshSecretBackendRole version is 0
message VaultSshSecretBackendRole {
  bool allow_bare_domains = 1 [json_name = "allow_bare_domains"];

  bool allow_host_certificates = 2 [json_name = "allow_host_certificates"];

  bool allow_subdomains = 3 [json_name = "allow_subdomains"];

  bool allow_user_certificates = 4 [json_name = "allow_user_certificates"];

  bool allow_user_key_ids = 5 [json_name = "allow_user_key_ids"];

  string allowed_critical_options = 6 [json_name = "allowed_critical_options"];

  string allowed_domains = 7 [json_name = "allowed_domains"];

  string allowed_extensions = 8 [json_name = "allowed_extensions"];

  map<string, string> allowed_user_key_lengths = 9;

  string allowed_users = 10 [json_name = "allowed_users"];

  string backend = 11;

  string cidr_list = 12 [json_name = "cidr_list"];

  map<string, string> default_critical_options = 13;

  map<string, string> default_extensions = 14;

  string default_user = 15 [json_name = "default_user"];

  string id = 16;

  string key_id_format = 17 [json_name = "key_id_format"];

  string key_type = 18 [json_name = "key_type"];

  string max_ttl = 19 [json_name = "max_ttl"];

  //Unique name for the role.
  string name = 20;

  string ttl = 21;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 22;

  int32 count = 23;

  terraform.meta.MetaFields.ForEachEntry for_each = 24;

  string provider = 25;

  terraform.meta.Lifecycle lifecycle = 26;
}

//VaultToken version is 0
message VaultToken {
  //The client token.
  string client_token = 1 [json_name = "client_token"];

  //The display name of the token.
  string display_name = 2 [json_name = "display_name"];

  //The client token encrypted using the provided PGP key.
  string encrypted_client_token = 3 [json_name = "encrypted_client_token"];

  //The explicit max TTL of the token.
  string explicit_max_ttl = 4 [json_name = "explicit_max_ttl"];

  string id = 5;

  //The token lease duration.
  int64 lease_duration = 6 [json_name = "lease_duration"];

  //The token lease started on.
  string lease_started = 7 [json_name = "lease_started"];

  //Flag to disable the default policy.
  bool no_default_policy = 8 [json_name = "no_default_policy"];

  //Flag to create a token without parent.
  bool no_parent = 9 [json_name = "no_parent"];

  //The number of allowed uses of the token.
  int64 num_uses = 10 [json_name = "num_uses"];

  //The period of the token.
  string period = 11;

  //The PGP key (base64 encoded) to encrypt the token.
  string pgp_key = 12 [json_name = "pgp_key"];

  //List of policies.
  repeated string policies = 13;

  //The renew increment.
  int64 renew_increment = 14 [json_name = "renew_increment"];

  //The minimum lease to renew token.
  int64 renew_min_lease = 15 [json_name = "renew_min_lease"];

  //Flag to allow the token to be renewed
  bool renewable = 16;

  //The token role name.
  string role_name = 17 [json_name = "role_name"];

  //The TTL period of the token.
  string ttl = 18;

  //The client wrapped token.
  string wrapped_token = 19 [json_name = "wrapped_token"];

  //The client wrapping accessor.
  string wrapping_accessor = 20 [json_name = "wrapping_accessor"];

  //The TTL period of the wrapped token.
  string wrapping_ttl = 21 [json_name = "wrapping_ttl"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 22;

  int32 count = 23;

  terraform.meta.MetaFields.ForEachEntry for_each = 24;

  string provider = 25;

  terraform.meta.Lifecycle lifecycle = 26;
}

//VaultTokenAuthBackendRole version is 0
message VaultTokenAuthBackendRole {
  //List of allowed policies for given role.
  repeated string allowed_policies = 1 [json_name = "allowed_policies"];

  //List of CIDRs valid as the source address for login requests. This value is also encoded into any resulting token.
  repeated string bound_cidrs = 2 [json_name = "bound_cidrs"];

  //List of disallowed policies for given role.
  repeated string disallowed_policies = 3 [json_name = "disallowed_policies"];

  //Number of seconds after which issued tokens can no longer be renewed.
  string explicit_max_ttl = 4 [json_name = "explicit_max_ttl"];

  string id = 5;

  //If true, tokens created against this policy will be orphan tokens.
  bool orphan = 6;

  //Tokens created against this role will have the given suffix as part of their path in addition to the role name.
  string path_suffix = 7 [json_name = "path_suffix"];

  //Number of seconds to set the TTL to for issued tokens upon renewal. Makes the token a periodic token, which will never expire as long as it is renewed before the TTL each period.
  string period = 8;

  //Whether to disable the ability of the token to be renewed past its initial TTL.
  bool renewable = 9;

  //Name of the role.
  string role_name = 10 [json_name = "role_name"];

  //Specifies the blocks of IP addresses which are allowed to use the generated token
  repeated string token_bound_cidrs = 11 [json_name = "token_bound_cidrs"];

  //Generated Token's Explicit Maximum TTL in seconds
  int64 token_explicit_max_ttl = 12 [json_name = "token_explicit_max_ttl"];

  //The maximum lifetime of the generated token
  int64 token_max_ttl = 13 [json_name = "token_max_ttl"];

  //If true, the 'default' policy will not automatically be added to generated tokens
  bool token_no_default_policy = 14 [json_name = "token_no_default_policy"];

  //The maximum number of times a token may be used, a value of zero means unlimited
  int64 token_num_uses = 15 [json_name = "token_num_uses"];

  //Generated Token's Period
  int64 token_period = 16 [json_name = "token_period"];

  //Generated Token's Policies
  repeated string token_policies = 17 [json_name = "token_policies"];

  //The initial ttl of the token to generate in seconds
  int64 token_ttl = 18 [json_name = "token_ttl"];

  //The type of token to generate, service or batch
  string token_type = 19 [json_name = "token_type"];

  terraform.meta.MetaFields.DependsOnEntry depends_on = 20;

  int32 count = 21;

  terraform.meta.MetaFields.ForEachEntry for_each = 22;

  string provider = 23;

  terraform.meta.Lifecycle lifecycle = 24;
}

//VaultTransformAlphabet version is 0
message VaultTransformAlphabet {
  //A string of characters that contains the alphabet set.
  string alphabet = 1;

  string id = 2;

  //The name of the alphabet.
  string name = 3;

  //The mount path for a back-end, for example, the path given in "$ vault auth enable -path=my-aws aws".
  string path = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultTransformRole version is 0
message VaultTransformRole {
  string id = 1;

  //The name of the role.
  string name = 2;

  //The mount path for a back-end, for example, the path given in "$ vault auth enable -path=my-aws aws".
  string path = 3;

  //A comma separated string or slice of transformations to use.
  repeated string transformations = 4;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 5;

  int32 count = 6;

  terraform.meta.MetaFields.ForEachEntry for_each = 7;

  string provider = 8;

  terraform.meta.Lifecycle lifecycle = 9;
}

//VaultTransformTemplate version is 0
message VaultTransformTemplate {
  //The alphabet to use for this template. This is only used during FPE transformations.
  string alphabet = 1;

  string id = 2;

  //The name of the template.
  string name = 3;

  //The mount path for a back-end, for example, the path given in "$ vault auth enable -path=my-aws aws".
  string path = 4;

  //The pattern used for matching. Currently, only regular expression pattern is supported.
  string pattern = 5;

  //The pattern type to use for match detection. Currently, only regex is supported.
  string type = 6;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 7;

  int32 count = 8;

  terraform.meta.MetaFields.ForEachEntry for_each = 9;

  string provider = 10;

  terraform.meta.Lifecycle lifecycle = 11;
}

//VaultTransformTransformation version is 0
message VaultTransformTransformation {
  //The set of roles allowed to perform this transformation.
  repeated string allowed_roles = 1 [json_name = "allowed_roles"];

  string id = 2;

  //The character used to replace data when in masking mode
  string masking_character = 3 [json_name = "masking_character"];

  //The name of the transformation.
  string name = 4;

  //The mount path for a back-end, for example, the path given in "$ vault auth enable -path=my-aws aws".
  string path = 5;

  //The name of the template to use.
  string template = 6;

  //Templates configured for transformation.
  repeated string templates = 7;

  //The source of where the tweak value comes from. Only valid when in FPE mode.
  string tweak_source = 8 [json_name = "tweak_source"];

  //The type of transformation to perform.
  string type = 9;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 10;

  int32 count = 11;

  terraform.meta.MetaFields.ForEachEntry for_each = 12;

  string provider = 13;

  terraform.meta.Lifecycle lifecycle = 14;
}

//VaultTransitSecretBackendKey version is 0
message VaultTransitSecretBackendKey {
  //If set, enables taking backup of named key in the plaintext format. Once set, this cannot be disabled.
  bool allow_plaintext_backup = 1 [json_name = "allow_plaintext_backup"];

  //The Transit secret backend the resource belongs to.
  string backend = 2;

  //Whether or not to support convergent encryption, where the same plaintext creates the same ciphertext. This requires derived to be set to true.
  bool convergent_encryption = 3 [json_name = "convergent_encryption"];

  //Specifies if the key is allowed to be deleted.
  bool deletion_allowed = 4 [json_name = "deletion_allowed"];

  //Specifies if key derivation is to be used. If enabled, all encrypt/decrypt requests to this key must provide a context which is used for key derivation.
  bool derived = 5;

  //Enables keys to be exportable. This allows for all the valid keys in the key ring to be exported. Once set, this cannot be disabled.
  bool exportable = 6;

  string id = 7;

  //List of key versions in the keyring.
  map<string, string> keys = 8;

  //Latest key version in use in the keyring
  int64 latest_version = 9 [json_name = "latest_version"];

  //Minimum key version available for use.
  int64 min_available_version = 10 [json_name = "min_available_version"];

  //Minimum key version to use for decryption.
  int64 min_decryption_version = 11 [json_name = "min_decryption_version"];

  //Minimum key version to use for encryption
  int64 min_encryption_version = 12 [json_name = "min_encryption_version"];

  //Name of the encryption key to create.
  string name = 13;

  //Whether or not the key supports decryption, based on key type.
  bool supports_decryption = 14 [json_name = "supports_decryption"];

  //Whether or not the key supports derivation, based on key type.
  bool supports_derivation = 15 [json_name = "supports_derivation"];

  //Whether or not the key supports encryption, based on key type.
  bool supports_encryption = 16 [json_name = "supports_encryption"];

  //Whether or not the key supports signing, based on key type.
  bool supports_signing = 17 [json_name = "supports_signing"];

  //Specifies the type of key to create. The currently-supported types are: aes128-gcm96, aes256-gcm96, chacha20-poly1305, ed25519, ecdsa-p256, ecdsa-p384, ecdsa-p521, rsa-2048, rsa-3072, rsa-4096
  string type = 18;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 19;

  int32 count = 20;

  terraform.meta.MetaFields.ForEachEntry for_each = 21;

  string provider = 22;

  terraform.meta.Lifecycle lifecycle = 23;
}

//VaultTransitSecretCacheConfig version is 0
message VaultTransitSecretCacheConfig {
  //The Transit secret backend the resource belongs to.
  string backend = 1;

  string id = 2;

  //Number of cache entries. A size of 0 mean unlimited.
  int64 size = 3;

  terraform.meta.MetaFields.DependsOnEntry depends_on = 4;

  int32 count = 5;

  terraform.meta.MetaFields.ForEachEntry for_each = 6;

  string provider = 7;

  terraform.meta.Lifecycle lifecycle = 8;
}
